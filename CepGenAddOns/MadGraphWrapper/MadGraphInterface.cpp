#ifndef MADGRAPH_BIN
#error "*** MADGRAPH_BIN variable not set! ***"
#endif
#ifndef MADGRAPH_PROC_TMPL
#error "*** MADGRAPH_PROC_TMPL variable not set! ***"
#endif
#ifndef CC_CFLAGS
#error "*** CC_CFLAGS variable not set! ***"
#endif

#include "CepGenAddOns/MadGraphWrapper/MadGraphInterface.h"
#include "CepGen/Utils/String.h"
#include "CepGen/Utils/Filesystem.h"
#include "CepGen/Core/Exception.h"
#include "CepGen/Physics/PDG.h"

#include <fstream>
#include <array>

namespace cepgen
{
  MadGraphInterface::MadGraphInterface( const ParametersList& params ) :
    proc_( params.get<std::string>( "process" ) ),
    model_( params.get<std::string>( "model" ) ),
    card_path_( params.get<std::string>( "cardPath", "/tmp/cepgen_mg5_input.dat" ) ),
    standalone_cpp_path_( params.get<std::string>( "standaloneCppPath" ) ),
    tmp_dir_( params.get<std::string>( "tmpDir", "/tmp/cepgen_mg5_aMC" ) ),
    log_filename_( params.get<std::string>( "logFile", "/tmp/cepgen_mg5_aMC.log" ) )
  {
    if ( proc_.empty() )
      throw CG_FATAL( "MadGraphInterface" )
        << "'process' keyword not set to the parameters!\n"
        << params;
    std::ofstream log( log_filename_, std::ios::trunc ); // clearing the log
  }

  std::string
  MadGraphInterface::run() const
  {
    std::ofstream log( log_filename_, std::ios::app ); // clearing the log

    std::string cpp_path;
    if ( !standalone_cpp_path_.empty() ) {
      CG_INFO( "MadGraphInterface:run" )
        << "Running on a process already generated by mg5_aMC:\n\t"
        << standalone_cpp_path_;
      cpp_path = standalone_cpp_path_;
    }
    else {
      CG_INFO( "MadGraphInterface:run" )
        << "Running the mg5_aMC process generation.";
      prepareCard();
      log << "\n\n*** mg5_aMC process generation ***\n\n";
      log << generateProcess( card_path_ );
      cpp_path = tmp_dir_;
    }

#ifdef _WIN32
    const std::string lib_path = "CepGenMadGraphProcess.dll";
#else
    const std::string lib_path = "libCepGenMadGraphProcess.so";
#endif

    CG_INFO( "MadGraphInterface:run" )
      << "Preparing the mg5_aMC process library.";
    log << "\n\n*** mg5_aMC process library compilation ***\n\n";
    const auto cg_proc = prepareMadGraphProcess();
    log << generateLibrary( cg_proc, cpp_path, lib_path );

    CG_INFO( "MadGraphInterface:run" )
      << "Creating links for all cards in current directory.";
    linkCards();

    return lib_path;
  }

  void
  MadGraphInterface::prepareCard() const
  {
    std::ofstream card( card_path_ );
    if ( !model_.empty() )
      card << "import model " << model_ << "\n";
    card << "generate " << proc_ << "\n";
    card << "output standalone_cpp " << tmp_dir_ << "\n";
    card << "exit\n";
    card.close();
  }

  std::string
  MadGraphInterface::prepareMadGraphProcess() const
  {
    //--- open template file
    std::ifstream tmpl_file( MADGRAPH_PROC_TMPL );
    std::string tmpl = std::string(
      std::istreambuf_iterator<char>( tmpl_file ),
      std::istreambuf_iterator<char>() );

    { //--- dirty fix to specify incoming- and outgoing states
      //    as extracted from the mg5_aMC process string
      auto proc_name = proc_;
      utils::trim( proc_name );
      const auto prim_proc = utils::split( proc_name, ',' )[0];
      auto parts = utils::split( prim_proc, '>' );
      if ( parts.size() != 2 )
        CG_FATAL( "MadGraphProcessBuilder" )
          << "Unable to unpack particles from process name: \"" << proc_name << "\"";
      for ( auto& p : parts )
        utils::trim( p );
      //--- incoming parton-like particles
      auto prim_parts = utils::split( parts[0], ' ' );
      for ( auto& p : prim_parts )
        utils::trim( p );
      if ( prim_parts.size() != 2 )
        CG_FATAL( "MadGraphProcessBuilder" )
          << "Unable to unpack particles from process name: \"" << proc_name << "\"";
      utils::replace_all( tmpl, "XXX_PART1_XXX", std::to_string( mg5_parts_.at( prim_parts[0] ) ) );
      utils::replace_all( tmpl, "XXX_PART2_XXX", std::to_string( mg5_parts_.at( prim_parts[0] ) ) );
      //---- outgoing system
      auto dec_parts = utils::split( parts[1], ' ' );
      std::ostringstream out_parts;
      std::string sep;
      for ( auto& p : dec_parts ) {
        utils::trim( p );
        out_parts << sep << mg5_parts_.at( p ), sep = ", ";
      }
      utils::replace_all( tmpl, "XXX_OUT_PART_XXX", out_parts.str() );
    }

    utils::replace_all( tmpl, "XXX_PROC_NAME_XXX", proc_ );
    std::string descr = proc_;
    if ( !model_.empty() )
      descr += " (model: "+model_+")";
    utils::replace_all( tmpl, "XXX_PROC_DESCRIPTION_XXX", descr );

    std::string src_filename = fs::path( tmp_dir_)/"cepgen_proc_interface.cpp";
    std::ofstream src_file( src_filename );
    src_file << tmpl;
    src_file.close();
    return src_filename;
  }

  void
  MadGraphInterface::linkCards() const
  {
    for ( const auto& f : fs::directory_iterator( fs::path( tmp_dir_ )/"Cards" ) )
      if ( f.path().extension() == ".dat" ) {
        fs::path link_path = f.path().filename();
        if ( !fs::exists( link_path ) )
          fs::create_symlink( f, link_path );
      }
  }

  std::string
  MadGraphInterface::generateProcess( const std::string& in_path )
  {
    std::string cmd = MADGRAPH_BIN;
    cmd += " -f "+in_path;
    return runCommand( cmd );
  }

  std::string
  MadGraphInterface::generateLibrary( const std::string& proc_path, const std::string& in_path, const std::string& out_lib )
  {
    std::vector<std::string> src_files;
    src_files.emplace_back( proc_path );

    const fs::path tmp_path( in_path );

    //--- find all processes registered
    std::vector<std::string> processes;
    try {
      for ( const auto& p : fs::directory_iterator( tmp_path/"SubProcesses" ) )
        if ( p.path().filename().string()[0] == 'P' ) {
          processes.emplace_back( p.path() );
          for ( const auto& f : fs::directory_iterator( p ) )
            if ( f.path().extension() == ".cc" )
              src_files.emplace_back( f.path() );
        }
    } catch ( const fs::filesystem_error& err ) {
      throw CG_FATAL( "MadGraphInterface:generateLibrary" )
        << "Failed to retrieve all subprocesses in path " << tmp_path << "!\n"
        << err.what();
    }

    if ( processes.size() != 1 )
      throw CG_FATAL( "MadGraphInterface:generateLibrary" )
        << "Currently only single-process cases are supported!";

    //--- find all model source files
    for ( const auto& f : fs::directory_iterator( tmp_path/"src" ) )
      if ( f.path().extension() == ".cc" )
        src_files.emplace_back( f.path() );

    std::string cmd = CC_CFLAGS;
    cmd += " -fPIC -shared";
    cmd += " -Wno-unused-variable -Wno-int-in-bool-context";
    cmd += " -I"+( tmp_path/"src" ).string();
    cmd += " -I"+processes.at( 0 );
    cmd += " "+utils::merge( src_files, " " );
    cmd += " -o "+out_lib;
    return runCommand( cmd );
  }

  std::string
  MadGraphInterface::runCommand( const std::string& cmd )
  {
    std::array<char,256> buffer;
    std::unique_ptr<FILE, decltype(&pclose)> pipe( popen( cmd.c_str(), "r" ), pclose );

    CG_DEBUG( "MadGraphInterface:runCommand" )
      << "Running\n\t" << cmd;

    std::string result;
    while ( fgets( buffer.data(), buffer.size(), pipe.get() ) )
      result += buffer.data();
    return result;
  }

  //----------------------------------------------------------------------------

  MadGraphProcess&
  MadGraphProcess::setMomentum( size_t i, const Momentum& mom )
  {
    if ( i > mom_.size() )
      throw CG_FATAL( "MadGraphProcess" )
        << "Invalid index for momentum: " << i << "!";
    mom_[i][0] = mom.energy();
    mom_[i][1] = mom.px();
    mom_[i][2] = mom.py();
    mom_[i][3] = mom.pz();
    return *this;
  }
}
