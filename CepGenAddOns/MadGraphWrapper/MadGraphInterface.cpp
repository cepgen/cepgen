#ifndef MADGRAPH_BIN
#error "*** MADGRAPH_BIN variable not set! ***"
#endif
#ifndef MADGRAPH_PROC_TMPL
#error "*** MADGRAPH_PROC_TMPL variable not set! ***"
#endif
#ifndef CC_CFLAGS
#error "*** CC_CFLAGS variable not set! ***"
#endif

#include "CepGenAddOns/MadGraphWrapper/MadGraphInterface.h"
#include "CepGen/Utils/String.h"
#include "CepGen/Utils/Filesystem.h"
#include "CepGen/Core/Exception.h"
#include "CepGen/Physics/PDG.h"

#include <fstream>
#include <array>

namespace cepgen {
  MadGraphInterface::MadGraphInterface(const ParametersList& params)
      : proc_(params.get<std::string>("process")),
        model_(params.get<std::string>("model")),
        card_path_(params.get<std::string>("cardPath", "/tmp/cepgen_mg5_input.dat")),
        standalone_cpp_path_(params.get<std::string>("standaloneCppPath")),
        tmp_dir_(params.get<std::string>("tmpDir", "/tmp/cepgen_mg5_aMC")),
        log_filename_(params.get<std::string>("logFile", "/tmp/cepgen_mg5_aMC.log")) {
    if (proc_.empty())
      throw CG_FATAL("MadGraphInterface") << "'process' keyword not set to the parameters!\n" << params;
    std::ofstream log(log_filename_, std::ios::trunc);  // clearing the log
  }

  std::string MadGraphInterface::run() const {
    std::ofstream log(log_filename_, std::ios::app);  // clearing the log

    std::string cpp_path;
    if (!standalone_cpp_path_.empty()) {
      CG_INFO("MadGraphInterface:run") << "Running on a process already generated by mg5_aMC:\n\t"
                                       << standalone_cpp_path_;
      cpp_path = standalone_cpp_path_;
    } else {
      CG_INFO("MadGraphInterface:run") << "Running the mg5_aMC process generation.";
      prepareCard();
      log << "\n\n*** mg5_aMC process generation ***\n\n";
      log << generateProcess(card_path_);
      cpp_path = tmp_dir_;
    }

#ifdef _WIN32
    const std::string lib_path = "CepGenMadGraphProcess.dll";
#else
    const std::string lib_path = "libCepGenMadGraphProcess.so";
#endif

    CG_INFO("MadGraphInterface:run") << "Preparing the mg5_aMC process library.";
    log << "\n\n*** mg5_aMC process library compilation ***\n\n";
    const auto cg_proc = prepareMadGraphProcess();
    log << generateLibrary(cg_proc, cpp_path, lib_path);

    CG_INFO("MadGraphInterface:run") << "Creating links for all cards in current directory.";
    linkCards();

    return lib_path;
  }

  void MadGraphInterface::prepareCard() const {
    std::ofstream card(card_path_);
    if (!model_.empty())
      card << "import model " << model_ << "\n";
    card << "generate " << proc_ << "\n";
    card << "output standalone_cpp " << tmp_dir_ << "\n";
    card << "exit\n";
    card.close();
  }

  std::string MadGraphInterface::prepareMadGraphProcess() const {
    //--- open template file
    std::ifstream tmpl_file(MADGRAPH_PROC_TMPL);
    std::string tmpl = std::string(std::istreambuf_iterator<char>(tmpl_file), std::istreambuf_iterator<char>());

    {  //--- dirty fix to specify incoming- and outgoing states
      //    as extracted from the mg5_aMC process string
      auto proc_name = proc_;
      utils::trim(proc_name);
      const auto prim_proc = utils::split(proc_name, ',')[0];
      auto parts = utils::split(prim_proc, '>');
      if (parts.size() != 2)
        CG_FATAL("MadGraphProcessBuilder") << "Unable to unpack particles from process name: \"" << proc_name << "\"";
      for (auto& p : parts)
        utils::trim(p);
      //--- incoming parton-like particles
      auto prim_parts = utils::split(parts[0], ' ');
      for (auto& p : prim_parts)
        utils::trim(p);
      if (prim_parts.size() != 2)
        CG_FATAL("MadGraphProcessBuilder") << "Unable to unpack particles from process name: \"" << proc_name << "\"";
      utils::replace_all(tmpl, "XXX_PART1_XXX", std::to_string(mg5_parts_.at(prim_parts[0])));
      utils::replace_all(tmpl, "XXX_PART2_XXX", std::to_string(mg5_parts_.at(prim_parts[0])));
      //---- outgoing system
      auto dec_parts = utils::split(parts[1], ' ');
      std::ostringstream out_parts;
      std::string sep;
      for (auto& p : dec_parts) {
        utils::trim(p);
        out_parts << sep << mg5_parts_.at(p), sep = ", ";
      }
      utils::replace_all(tmpl, "XXX_OUT_PART_XXX", out_parts.str());
    }

    utils::replace_all(tmpl, "XXX_PROC_NAME_XXX", proc_);
    std::string descr = proc_;
    if (!model_.empty())
      descr += " (model: " + model_ + ")";
    utils::replace_all(tmpl, "XXX_PROC_DESCRIPTION_XXX", descr);

    std::string src_filename = fs::path(tmp_dir_) / "cepgen_proc_interface.cpp";
    std::ofstream src_file(src_filename);
    src_file << tmpl;
    src_file.close();
    return src_filename;
  }

  void MadGraphInterface::linkCards() const {
    for (const auto& f : fs::directory_iterator(fs::path(tmp_dir_) / "Cards"))
      if (f.path().extension() == ".dat") {
        fs::path link_path = f.path().filename();
        if (!fs::exists(link_path))
          fs::create_symlink(f, link_path);
      }
  }

  std::string MadGraphInterface::generateProcess(const std::string& in_path) {
    std::string cmd = MADGRAPH_BIN;
    cmd += " -f " + in_path;
    return runCommand(cmd);
  }

  std::string MadGraphInterface::generateLibrary(const std::string& proc_path,
                                                 const std::string& in_path,
                                                 const std::string& out_lib) {
    std::vector<std::string> src_files;
    src_files.emplace_back(proc_path);

    const fs::path tmp_path(in_path);

    //--- find all processes registered
    std::vector<std::string> processes;
    try {
      for (const auto& p : fs::directory_iterator(tmp_path / "SubProcesses"))
        if (p.path().filename().string()[0] == 'P') {
          processes.emplace_back(p.path());
          for (const auto& f : fs::directory_iterator(p))
            if (f.path().extension() == ".cc")
              src_files.emplace_back(f.path());
        }
    } catch (const fs::filesystem_error& err) {
      throw CG_FATAL("MadGraphInterface:generateLibrary")
          << "Failed to retrieve all subprocesses in path " << tmp_path << "!\n"
          << err.what();
    }

    if (processes.size() != 1)
      throw CG_FATAL("MadGraphInterface:generateLibrary") << "Currently only single-process cases are supported!";

    //--- find all model source files
    for (const auto& f : fs::directory_iterator(tmp_path / "src"))
      if (f.path().extension() == ".cc")
        src_files.emplace_back(f.path());

    std::string cmd = CC_CFLAGS;
    cmd += " -fPIC -shared";
    cmd += " -Wno-unused-variable -Wno-int-in-bool-context";
    cmd += " -I" + (tmp_path / "src").string();
    cmd += " -I" + processes.at(0);
    cmd += " " + utils::merge(src_files, " ");
    cmd += " -o " + out_lib;
    return runCommand(cmd);
  }

  std::string MadGraphInterface::runCommand(const std::string& cmd) {
    std::array<char, 256> buffer;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), "r"), pclose);

    CG_DEBUG("MadGraphInterface:runCommand") << "Running\n\t" << cmd;

    std::string result;
    while (fgets(buffer.data(), buffer.size(), pipe.get()))
      result += buffer.data();
    return result;
  }

  //----------------------------------------------------------------------------

  MadGraphProcess& MadGraphProcess::setMomentum(size_t i, const Momentum& mom) {
    if (i > mom_.size())
      throw CG_FATAL("MadGraphProcess") << "Invalid index for momentum: " << i << "!";
    mom_[i][0] = mom.energy();
    mom_[i][1] = mom.px();
    mom_[i][2] = mom.py();
    mom_[i][3] = mom.pz();
    return *this;
  }
}  // namespace cepgen
