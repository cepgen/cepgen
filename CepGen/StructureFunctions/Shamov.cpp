#include "CepGen/StructureFunctions/Parameterisation.h"
#include "CepGen/StructureFunctions/SuriYennie.h"
#include "CepGen/Modules/StructureFunctionsFactory.h"

#include "CepGen/Core/Exception.h"

#include "CepGen/Physics/PDG.h"
#include "CepGen/Physics/Constants.h"
#include "CepGen/Utils/GridHandler.h"

#include <complex>
#include <vector>

namespace cepgen
{
  namespace strfun
  {
    class Shamov : public Parameterisation
    {
      public:
        explicit Shamov( const ParametersList& params = ParametersList() );
        static std::string description() { return "Shamov composite soft structure functions"; }

        Shamov& operator()( double xbj, double q2 ) override;

        double W1, W2;

      private:
        static constexpr float gm0_ = 1., gmb_ = 0.984;
        static constexpr std::array<float,19> gmv_ = { { 3., 1.77, 1.38, 1.17, 0.978, 0.961, 0.964, 0.766, 0.735, 0.719, 0.57, 0.572, 0.553, 0.460, 0.446, 0.326, 0.269, 0.209, 0.102 } };
        static constexpr std::array<float,19> gmq_ = { { 0., 0.2, 0.3, 0.4, 0.47, 0.48, 0.5, 0.6, 0.63, 0.63, 0.77, 0.78, 0.79, 0.97, 0.98, 1.15, 1.34, 1.57, 2.34 } };
        static constexpr std::array<float,290> gp_cs_ = { {
          0., 0.052, 0.108, 0.175, 0.424, 0.487, 0.527, 0.478, 0.407, 0.334, 0.244, 0.225, 0.200, 0.178, 0.177, 0.187, 0.194, 0.212, 0.223, 0.233,
          0.211, 0.240, 0.265, 0.279, 0.276, 0.261, 0.245, 0.201, 0.221, 0.206, 0.214, 0.209, 0.202, 0.193, 0.205, 0.201, 0.212, 0.218, 0.215, 0.192,
          0.191, 0.175, 0.165, 0.182, 0.159, 0.162, 0.150, 0.149, 0.144, 0.156, 0.150, 0.147, 0.154, 0.154, 0.154, 0.147, 0.154, 0.154, 0.144, 0.152,
          0.151, 0.156, 0.154, 0.146, 0.139, 0.156, 0.150, 0.150, 0.145, 0.139, 0.145, 0.146, 0.142, 0.141, 0.142, 0.143, 0.149, 0.154, 0.135, 0.115,
          0.148, 0.144, 0.144, 0.143, 0.142, 0.149, 0.144, 0.148, 0.138, 0.132, 0.145, 0.138, 0.145, 0.136, 0.138, 0.138, 0.139, 0.136, 0.129, 0.136,
          0.140, 0.144, 0.133, 0.139, 0.139, 0.143, 0.140, 0.140, 0.139, 0.134, 0.141, 0.130, 0.136, 0.124, 0.132, 0.128, 0.130, 0.142, 0.132, 0.134,
          0.139, 0.133, 0.144, 0.133, 0.135, 0.136, 0.130, 0.134, 0.134, 0.111, 0.130, 0.131, 0.130, 0.129, 0.140, 0.134, 0.138, 0.129, 0.144, 0.128,
          0.133, 0.132, 0.127, 0.128, 0.127, 0.124, 0.124, 0.133, 0.127, 0.127, 0.121, 0.134, 0.129, 0.134, 0.123, 0.129, 0.132, 0.121, 0.137, 0.123,
          0.130, 0.135, 0.127, 0.129, 0.128, 0.126, 0.123, 0.122, 0.120, 0.119, 0.128, 0.134, 0.132, 0.125, 0.122, 0.126, 0.114, 0.127, 0.135, 0.122,
          0.140, 0.125, 0.136, 0.116, 0.136, 0.124, 0.131, 0.127, 0.146, 0.136, 0.120, 0.131, 0.142, 0.132, 0.129, 0.132, 0.134, 0.133, 0.133, 0.127,
          0.128, 0.116, 0.125, 0.127, 0.124, 0.122, 0.134, 0.122, 0.128, 0.122, 0.122, 0.130, 0.118, 0.125, 0.124, 0.121, 0.116, 0.122, 0.129, 0.122,
          0.120, 0.118, 0.126, 0.122, 0.124, 0.124, 0.122, 0.120, 0.119, 0.123, 0.115, 0.124, 0.114, 0.123, 0.117, 0.120, 0.122, 0.128, 0.124, 0.112,
          0.128, 0.121, 0.122, 0.115, 0.115, 0.118, 0.116, 0.111, 0.115, 0.118, 0.119, 0.113, 0.113, 0.115, 0.114, 0.113, 0.115, 0.117, 0.115, 0.114,
          0.114, 0.114, 0.115, 0.112, 0.114, 0.115, 0.115, 0.115, 0.114, 0.113, 0.114, 0.115, 0.115, 0.114, 0.114, 0.117, 0.116, 0.116, 0.116, 0.114,
          0.117, 0.116, 0.114, 0.116, 0.120, 0.116, 0.118, 0.143, 0.143, 0.143 } };
        static constexpr std::array<float,290> gp_en_ = { {
          1.070, 1.100, 1.130, 1.150, 1.174, 1.194, 1.213, 1.232, 1.251, 1.270, 1.288, 1.306, 1.324, 1.342, 1.359, 1.376, 1.393, 1.410, 1.426, 1.443,
          1.456, 1.459, 1.475, 1.491, 1.506, 1.522, 1.537, 1.543, 1.552, 1.567, 1.582, 1.597, 1.612, 1.617, 1.626, 1.640, 1.655, 1.669, 1.683, 1.697,
          1.710, 1.724, 1.738, 1.743, 1.751, 1.764, 1.778, 1.791, 1.804, 1.817, 1.830, 1.830, 1.843, 1.855, 1.868, 1.880, 1.893, 1.898, 1.905, 1.917,
          1.922, 1.930, 1.942, 1.954, 1.966, 1.978, 1.989, 2.001, 2.013, 2.025, 2.036, 2.041, 2.048, 2.059, 2.070, 2.082, 2.093, 2.104, 2.115, 2.117,
          2.126, 2.137, 2.148, 2.153, 2.153, 2.159, 2.170, 2.174, 2.181, 2.191, 2.202, 2.213, 2.223, 2.234, 2.238, 2.244, 2.255, 2.265, 2.275, 2.286,
          2.296, 2.300, 2.306, 2.316, 2.320, 2.326, 2.336, 2.346, 2.356, 2.360, 2.366, 2.376, 2.386, 2.396, 2.400, 2.406, 2.415, 2.419, 2.425, 2.435,
          2.444, 2.454, 2.464, 2.473, 2.477, 2.483, 2.492, 2.501, 2.511, 2.513, 2.520, 2.529, 2.533, 2.539, 2.548, 2.551, 2.557, 2.566, 2.575, 2.584,
          2.593, 2.602, 2.611, 2.620, 2.624, 2.629, 2.638, 2.642, 2.647, 2.649, 2.656, 2.665, 2.674, 2.682, 2.691, 2.695, 2.700, 2.708, 2.717, 2.726,
          2.734, 2.743, 2.746, 2.751, 2.760, 2.763, 2.768, 2.777, 2.785, 2.794, 2.797, 2.802, 2.810, 2.819, 2.827, 2.830, 2.835, 2.844, 2.847, 2.852,
          2.860, 2.868, 2.876, 2.876, 2.885, 2.893, 2.896, 2.896, 2.901, 2.909, 2.917, 2.919, 2.925, 2.933, 2.941, 2.944, 2.949, 2.957, 2.957, 2.965,
          3.032, 3.035, 3.038, 3.114, 3.130, 3.147, 3.207, 3.218, 3.253, 3.296, 3.305, 3.383, 3.389, 3.416, 3.471, 3.479, 3.540, 3.551, 3.582, 3.634,
          3.683, 3.784, 3.867, 3.867, 3.911, 3.937, 4.029, 4.087, 4.144, 4.204, 4.257, 4.282, 4.327, 4.334, 4.379, 4.396, 4.458, 4.514, 4.580, 4.580,
          4.645, 4.715, 4.773, 4.860, 4.912, 4.931, 5.001, 5.065, 5.140, 5.140, 5.213, 5.356, 5.374, 5.541, 5.623, 5.704, 5.862, 5.935, 6.665, 7.271,
          7.672, 7.733, 8.066, 8.329, 8.485, 9.125, 9.186, 9.576, 9.979, 15.1, 20., 30., 40., 50., 60., 70., 80., 90., 100., 120.,
          150., 170., 200., 240., 270., 310., 350., 400., 500., 7000. } };
        static constexpr std::array<float,290> gp_nr_ = { {
          0.683, 0.539, 0.374, 0.267, 0.378, 0.143, 0.085, 0.137, 0.233, 0.297, 0.249, 0.333, 0.364, 0.365, 0.408, 0.460, 0.476, 0.494, 0.472, 0.431,
          0.303, 0.374, 0.376, 0.384, 0.394, 0.412, 0.444, 0.357, 0.458, 0.486, 0.553, 0.576, 0.577, 0.559, 0.580, 0.545, 0.530, 0.531, 0.568, 0.590,
          0.655, 0.677, 0.699, 0.740, 0.720, 0.750, 0.749, 0.765, 0.771, 0.800, 0.803, 0.799, 0.817, 0.825, 0.831, 0.830, 0.844, 0.846, 0.839, 0.852,
          0.853, 0.860, 0.863, 0.859, 0.856, 0.876, 0.874, 0.877, 0.876, 0.873, 0.881, 0.883, 0.881, 0.883, 0.886, 0.889, 0.895, 0.901, 0.889, 0.870,
          0.900, 0.900, 0.901, 0.901, 0.900, 0.906, 0.904, 0.908, 0.902, 0.899, 0.909, 0.906, 0.912, 0.908, 0.910, 0.910, 0.912, 0.911, 0.908, 0.914,
          0.917, 0.920, 0.914, 0.919, 0.919, 0.922, 0.921, 0.922, 0.923, 0.920, 0.925, 0.919, 0.924, 0.917, 0.923, 0.921, 0.923, 0.929, 0.925, 0.927,
          0.930, 0.927, 0.934, 0.929, 0.930, 0.931, 0.929, 0.931, 0.932, 0.918, 0.931, 0.932, 0.931, 0.931, 0.937, 0.935, 0.937, 0.933, 0.940, 0.934,
          0.937, 0.937, 0.935, 0.936, 0.936, 0.935, 0.935, 0.939, 0.937, 0.937, 0.935, 0.941, 0.939, 0.942, 0.937, 0.941, 0.942, 0.937, 0.945, 0.939,
          0.943, 0.945, 0.942, 0.943, 0.943, 0.942, 0.941, 0.941, 0.941, 0.941, 0.945, 0.948, 0.947, 0.944, 0.943, 0.946, 0.940, 0.946, 0.950, 0.945,
          0.952, 0.947, 0.951, 0.943, 0.952, 0.947, 0.950, 0.948, 0.955, 0.952, 0.946, 0.951, 0.955, 0.952, 0.951, 0.952, 0.953, 0.953, 0.953, 0.951,
          0.954, 0.949, 0.953, 0.956, 0.955, 0.955, 0.960, 0.957, 0.960, 0.959, 0.959, 0.963, 0.960, 0.962, 0.963, 0.962, 0.962, 0.964, 0.966, 0.966,
          0.966, 0.967, 0.970, 0.969, 0.970, 0.971, 0.971, 0.971, 0.972, 0.973, 0.972, 0.974, 0.973, 0.975, 0.974, 0.975, 0.976, 0.977, 0.977, 0.975,
          0.978, 0.978, 0.978, 0.978, 0.978, 0.979, 0.979, 0.978, 0.979, 0.980, 0.981, 0.980, 0.980, 0.982, 0.982, 0.982, 0.983, 0.984, 0.986, 0.987,
          0.988, 0.988, 0.989, 0.989, 0.990, 0.991, 0.991, 0.991, 0.992, 0.992, 0.992, 0.993, 0.993, 0.993, 0.993, 0.994, 0.994, 0.994, 0.994, 0.995,
          0.995, 0.995, 0.995, 0.995, 0.996, 0.996, 0.996, 1., 1., 1. } };
        static constexpr std::array<float,2> q20_ = { { 0.36, 0.65 } };
        static constexpr std::array<float,2> r_power_ = { { 0.52, 0.71 } };

        /// q^2 dependence of the non-resonant gamma-p cross section
        /// Some fit of the know e-p data. Good only for Q^2 < 6 GeV^2
        float qsdepnr( float q2, int fit ) const {
          return 1./pow( 1.+pow( q2/q20_[fit], 2 ), r_power_[fit] );
        }

        const enum class Mode {
          SuriYennie = 0, ///< Suri & Yennie
          /// real photon cross section for q^2=0,
          /// q^2 dependence as for Delta(1232)
          RealRes = 1,
          /// real photon cross section for q^2=0,
          /// q^2 dependence: resonant contribution as for Delta(1232),
          /// nonresonant contribution according to S&Y
          RealResAndNonRes = 2,
          /// real photon cross section for q^2=0,
          /// q^2 dependence according to S&Y
          RealAndSuriYennieNonRes = 3,
          /// real photon cross section for q^2=0,
          /// q^2 dependence: resonant contribution as for Delta(1232),
          /// some fit for nonresonant contribution
          RealAndFitNonRes = 4
        } mode_;

        GridHandler<1,2> sigma_grid_;
        GridHandler<1,1> gm_grid_;
        SuriYennie sy_sf_;
        const double m_min_;
    };

    constexpr std::array<float,19> Shamov::gmv_, Shamov::gmq_;
    constexpr std::array<float,290> Shamov::gp_en_, Shamov::gp_cs_, Shamov::gp_nr_;
    constexpr std::array<float,2> Shamov::q20_, Shamov::r_power_;

    Shamov::Shamov( const ParametersList& params ) :
      Parameterisation( params ),
      mode_( (Mode)params.get<int>( "mode", (int)Mode::RealResAndNonRes ) ),
      sigma_grid_( GridType::linear ), gm_grid_( GridType::linear ),
      m_min_( mp_+0.1396 )
    {
      for ( size_t i = 0; i < gp_en_.size(); ++i )
        sigma_grid_.insert( { gp_en_.at( i ) }, { gp_cs_.at( i ), gp_nr_.at( i ) } );
      for ( size_t i = 0; i < gmv_.size(); ++i )
        gm_grid_.insert( { gmq_.at( i ) }, { gmv_.at( i ) } );
    }

    Shamov&
    Shamov::operator()( double xbj, double q2 )
    {
      std::pair<double,double> nv = { xbj, q2 };
      if ( nv == old_vals_ )
        return *this;
      old_vals_ = nv;

      //--- Suri & Yennie structure functions
      auto sy = sy_sf_( xbj, q2 );

      if ( mode_ == Mode::SuriYennie ) {
        W1 = sy.W1;
        W2 = sy.W2;
        F2 = sy.F2;
        return *this;
      }

      const double mx2 = mp2_+q2*( 1.-xbj )/xbj, mx = sqrt( mx2 );

      const double w1_sy = sy.W1;
      const double w2_sy = sy.W2;

      const auto sigma = sigma_grid_.eval( { mx } );
      auto sgp = sigma[0];

      double Gm;

      //--- q^2 dependence of sigma
      if ( ( mode_ == Mode::RealAndSuriYennieNonRes
        || ( mode_ == Mode::RealAndFitNonRes && mx < 1.5 )
        || ( mode_ == Mode::RealResAndNonRes || mode_ == Mode::RealAndFitNonRes ) )
        && ( mx > sigma_grid_.boundaries()[0].second || rand()*1./RAND_MAX < sigma[1] ) ) {
        // nonresonant
        if ( mode_ == Mode::RealAndFitNonRes )
          Gm = qsdepnr( q2, 2 );
        else {
          auto sy = sy_sf_( xbj, 1.e-7 );
          Gm = sy.W1/sy.W2;
        }
      }
      else { // resonant
        if ( q2 >= *gmq_.rbegin() )
          Gm = gm0_/exp( gmb_*q2 );
        else
          Gm = gm_grid_.eval( { q2 } )[0];
        Gm /= 3.; // due to data normalization
      }
      sgp *= Gm; // cross section with some q^2 dependence

      //--- for W -> cross section
      const double prefac = 2.*M_PI*M_PI*constants::ALPHA_EM*constants::GEVM2_TO_PB*1e-9; // mb/GeV
      const double s1 = prefac*4.*mp_/( mx2-mp2_ ); // mb/GeV
      const double s2 = prefac*( pow( mx2-mp2_, 2 )+2.*( mx2+mp2_ )*q2 + q2*q2 )/mp_/q2/( mx2-mp2_ ); // mb/GeV
      //---  ratio (\sigma_T+\sigma_L)/\sigma_T according to S & Y
      const double ratio = ( s2*w2_sy )/( s1*w1_sy );

      if ( mode_ == Mode::RealAndFitNonRes ) { // Sgp = \sigma_T
        W1 = sgp/s1;
        W2 = sgp*ratio/s2;
      }
      else { // Sgp = \sigma_L+\sigma_T
        W1 = sgp/ratio/s1;
        W2 = sgp/s2;
      }
      const double nu = 0.5*mx/mp_;
      F2 = 2.*W2*nu/mp_;
      return *this;
    }
  }
}

REGISTER_STRFUN( Shamov, strfun::Shamov )
